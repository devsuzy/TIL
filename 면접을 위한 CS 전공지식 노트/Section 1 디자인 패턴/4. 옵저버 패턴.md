# Section 1 디자인 패턴

## 옵저버 패턴

### 특징
- 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 생기면 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴
- 주체: 객체의 상태 변화를 보는 관찰자
- 옵저버: 주체에게 전달되는 메서드를 기반으로 변경 사항이 생기는 객체
- 주로 이벤트 기반 시스템에 사용
- MVC(Model-View-Controller)패턴에서도 사용

### 자바스크립트에서 옵저버 패턴
- 프록시 객체를 통해 구현 가능
- 프록시 객체
    - 어떤 대상의 기본적인 동작이나 작업을 가로챌 수 있는 객체
    - `target`: 프록시할 대상
    - `handler`: target 동작을 가로채고 어떠한 동작을 할 것인지 설정되어 있는 함수
```js
const handler = {
    get: function(target, name) {
        return name === 'name' ? `${target.a} ${target.b}` : target[name]
    }
}

const p = new Proxy({ a: 'KUNDOL', b: 'IS AUMUMU ZANGIN' }, handler);
console.log(p.name); // KUNDOL IS AUMUMU ZANGIN
```
- p의 name 속성에 접근함
- `handler` 함수가 name 속성에 접근할 때, 그 부분을 가로채서 자신의 로직을 강제함

### Vue.js 3.0의 옵저버 패턴
```js
function createReactiveObject(
    target: Target,
    isReadonly: boolean,
    baseHandlers: ProxyHandler<any>,
    collectionHandlers: ProxyHandler<any>,
    proxyMap: WeakMap<Target, any>
){
    if (!isObject(target)) {
        if (__DEV__) {
            console.warn(`value cannot be made reactive: ${String(target)}`)
        }
        return target;
    }
    if(
        target[ReactiveFlas.RAW] &&
        !(isReadonly && target[ReactiveFlags.IS_REACTIVE])
    ) {
        return target;
    }

    const existingProxy = proxyMap.get(target);
    if (existingProxy) return existingProxy;

    const targetType = getTargetType(target);
    if (targetType === TargetType.INVALID) {
        return target;
    }

    const proxy = new Proxy(
        target,
        targetType === TargetType.COLLECTION ? collectionHanlders : baseHanlders
    );

    proxyMap.set(target, proxy);
    return proxy
}
```
- `get()`: 속성에 접근할 때 옵저버를 등록
- `set()`: 속성이 변경될 때 모든 옵저버에게 알림을 보냄